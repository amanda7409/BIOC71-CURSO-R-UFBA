######################################################
# Introdu√ß√£o Linguagem R
# Vitor Passos Rios
# Universidade Federal da Bahia
# https://github.com/vrios/Intro-Linguagem-R/wiki
#####################################################

#quando poss√?vel, sua resposta deve ser um c√≥digo do R

#####Trabalhando com dados#####
# o que √© um dataframe? Qual a diferne√ßa entre um dataframe e um list? # e semelhante a uma matriz, mas o data frame pode ser constituido de palavras(nomes) ou dados de tipos diferentes, enquanto uma lista √© formada pelo comando list e pode ser composta por vetores de diferentes classes e tamanhos.

# o que as fun√ß√µes abaixo fazem? O que elas retornam?
is.vector() # testa se o objeto e um vetor / retorna VERDADEIRO se o objeto for um vetor
is.numeric() # testa se o objeto e um numero / retorna VERDADEIRO se o objeto for um numero
is.character() # testa se o objeto e um caracter / retorna VERDADEIRO se o objeto for um caracter
is.matrix(peso)
is.na()
is.data.frame() # testa se o objeto e um data.frame / se sim, haver√° um resultado (retorno) verdadeiro


#o que queremos dizer quando dizemos uma fun√ß√£o "retorna" alguma coisa? # queremos dizer que a funcao retorna (da o resultado) dos objetos criados e salvos, para isso utilizar a funcao ls()

#o que a fun√ß√£o summary() faz? # essa funcao retorna a media, mediana, maximo e minimo de uma variavel x


#Tr√™s √°reas foram submetidas aplica√ß√£o de tr√™s adubos diferentes, e uma foi
#mantida como controle. A biomassa seca (kg) por parcela foi medida para
#verificar se houve efeito do adubo. Os dados obtidos foram:

#(Controle)	A	37	34	36	42	31  33
#B	62	54	57	64	60
#C	63	58	60	62	61 44
#D	41	37	38	49	35 49
#Crie um dataframe com estes dados

tratamentos=c(rep("a",6), rep("b", 5), rep("c", 6), rep("d", 6))
pesos = c(37, 34, 36, 42, 31, 33, 62, 54, 57, 64, 60, 63, 58, 60, 62, 61, 44, 41, 37, 38, 49, 35, 49)
adubados=data.frame(tratamentos,pesos)



#Calcule a m√©dia de cada tipo de adubo, sem usar summary(), usando o dataframe
#que voc√™ criou acima

media.a=mean(adubados$pesos[adubados$tratamentos == "a"])

#que problemas voc√™ teve ao fazer o exerc√?cio acima? # um pouco de problema pra entender como estruturar o []

# O que a fun√ß√£o unique() faz? # serve para verificar erros de digitacao e quando trabalha-se com textos ou ignorar repeticoes

#Usando o conjunto de dados caixeta.csv, disponivel em
#http://ecologia.ib.usp.br/bie5782/doku.php?id=dados:dados-caixeta, calcule
#quantas esp√©cies est√£o presentes na coluna especie. Para ler o arquivo, execute # 1027 esp√©cies
#o c√≥digo abaixo
caixeta = read.table("caixeta.csv", header=T, sep=",", as.is=T)

# o arquivo deve estar no seu diret√≥rio de trabalho
str(caixeta) #o que este comando faz? # mostra a estrutura interna do objeto

summary(caixeta) # esse comando retorna a media, mediana, maximo e minimo do objeto

#podemos criar uma coluna a mais no nosso dataframe apenas dizendo ao R o que
#colocar l√°. Por exemplo, criamos uma coluna com o nome do coletor do dado
caixeta$coletor= "Darwin" #regra da reciclagem
str(caixeta)

#agora adicione no objeto caixeta uma coluna chamada "desvio" com o quanto a
#altura de cada √°rvore difere da m√©dia de todas as √°rvores

caixeta$desvio = caixeta$h - mean(caixeta$h)


#Usando a fun√ß√£o table(), conte quantos indiv√?duos de cada esp√©cie existem
table(caixeta$especie)

#A fun√ß√£o table() tamb√©m pode contar por esp√©cie em cada local, depois por local
#em cada esp√©cie). Como?

table(caixeta$especie, caixeta$local)

#crie um objeto chamado pequenas que contenha todas as √°rvores com altura (h)
#menor que um metro.(Os dados no arquivo est√£o em cent√?metros)

pequenas = caixeta[caixeta$h < 100,]


#crie um objeto chamado grandes que contenha todas as √°rvores acima de 3 metros

grandes = caixeta[caixeta$h > 300,]

#crie um objeto chamado medias que todas as √°rvores com alturas entre um metro e
#tres metros

medias = caixeta[caixeta$h>=100 & caixeta$h<=300,]

#agora em uma linha de comando, crie um objeto que contenha a quantidade de
#√°rvores pequenas, m√©dias e grandes, separadamente

todas = c(length(pequenas$local), length(medias$local), length(grandes$local))
todas
dim(pequenas)

#Crie um objeto chamado obj somente com os individuos de "Alchornea
#triplinervia" Em quantas localidades esta esp√©cie ocorre? Qual comando para
#encontrar essa informa√ß√£o?

obj = caixeta[caixeta$especie == "Alchornea triplinervia",]

#podemos remover dados de um dataframe, usando o sinal de menos

table(obj$local)

caixeta.sem.tabebuia = caixeta[ - wich(caixeta$especie=="Tabebuia cassinoides"),]
sort(
unique(caixeta.sem.tabebuia$especie
)

#agora crie um objeto removendo todas as "Tabebuia cassinoides" do local retiro
#(somente do local retiro)

caixeta.sem.retiro = caixeta[
                
                            !c(#exclamaÁ„o È nao: nao pegue o que cumpre as condicoes a seguir
                            caixeta$local =="retiro"
                            &
                            caixeta$especie == "Tabebuia cassinoides"
                            ),
                            ]


#crie os objetos abaixo, junte eles num dataframe de duas colunas chamado comNA,
#depois crie um novo objeto chamado semNA, removendo todas as linhas que
#contenham NA, usando a nota√ß√£o acima (dica: s√≥ se usa "" para valores do tipo
#character)
id = 1:80
a = c(121.72355, 103.79754, 130.15442, 98.29305, 103.43365, 102.44998,
      NA, 111.07215, 113.74047, 103.16081, 80.87149, 98.66692,
      65.09549, 155.74965, 88.30168, 147.43610, 114.60806, 109.87433,
      149.54772, 83.54137
)
b = c(77.91352, 78.07251, 81.95604, 75.64862, 78.45213, 79.11058,
      79.98952, 79.18127, 840.1635, 74.86860, 82.01886, 78.26936,
      77.94691, 78.75372, 77.64901, NA, 77.19803, 72.48175,
      83.45336, 78.99681
)
c = c(127.9366, 201.7158, NA, 136.5880, 131.7213, 118.1486,
      125.7534, 139.6544, 163.5890, 139.7455, NA, 141.4450, 110.7311,
      157.5921, 176.8437, 102.8659, 121.8286, 134.7097, 157.1392, 166.7133
)
d = c(191.3721, 216.1671, 165.4380, 196.2730, 172.6565, 178.2955,
      193.6687, NA, 160.2968, 208.4400, 204.0934, 208.1798,
      186.6380, 193.9446, NA, 198.6853, 213.8838, 210.1881,
      209.9109, 210.9228
)

comNA = data.frame(id,c(a,b,c,d))
semNA = comNA[!is.na(comNA$c.a.b..c..d.),]
semNA2 = na.omit(comNA)



#Abaixo temos dados de tamanho de mand√?bula de chacal dourado. Crie um dataframe
#com esses dados. Qual a m√©dia por sexo? E para a esp√©cie? Guarde estes valores
#em tres objetos diferentes.

#machos: 120 107 110 116 114 111 113 117 114 112

#femeas: 110 111 107 108 110 105 107 106 111 111 Quantos machos t√™m a mand√?bula

#maior do que a m√©dia das f√™meas?

machos = c(107, 107, 110, 116, 114, 111, 113, 117, 114, 112)
femeas = c(110, 111, 107, 108, 110, 105, 107, 106, 111, 111)
chacais = data.frame(machos,femeas)
media.m = mean(machos)
media.f = mean(femeas)
media.sp = mean(c(machos,femeas))
machos.grandes = machos [machos > media.f]
machos.grandes
machos.grandes2 = chacais$machos[chacais$machos > media.f]

#escreva **uma** linha de c√≥digo que testa se um n√∫mero √© par, e caso seja,

#manda uma mensagem dizendo "par". dica: use a fun√ß√£o %% (resto da divis√£o, ou
#remainder em ingl√™s) e a fun√ß√£o message()

if(8 %% 2 == 0){
  message("par")
} else {
    message("impar")
  }

if(x>4*mean(dados)){dados{-x}}

vacas = c(121.72355, 103.79754, 130.15442, 98.29305, 103.43365, 102.44998, 125.49993, 
          111.07215, 113.74047, 103.16081, 80.87149, 98.66692, 65.09549, 155.74965, 
          88.30168, 147.4361, 114.60806, 109.87433, 149.54772, 83.54137)
fazendeiros = c(77.91352, 78.07251, 81.95604, 75.64862, 78.45213, 79.11058, 
                79.98952, 79.18127, 840.1635, 74.8686, 82.01886, 78.26936, 77.94691, 78.75372, 
                77.64901, 77.64097, 77.19803, 72.48175, 83.45336, 78.99681)
virgens = c(127.9366, 201.7158, 136.1366, 136.588, 131.7213, 118.1486, 125.7534, 
            139.6544, 163.589, 139.7455, NA, 141.445, 110.7311, 157.5921, 176.8437, 
            102.8659, 121.8286, 134.7097, 157.1392, 166.7133)
aventureiros = c(191.3721, 216.1671, 165.438, 196.273, 172.6565, 178.2955, 193.6687, 
                 189.7674, 160.2968, 208.44, 204.0934, 208.1798, 186.638, 193.9446, 197.365, 
                 198.6853, 213.8838, 210.1881, 209.9109, 210.9228)


alimento = c(rep("vacas", 20), rep("fazendeiros", 20), rep("virgens", 20), rep("aventureiros", 20))
dragoes=data.frame(x = alimento, y = c(vacas, fazendeiros, virgens, aventureiros))
head(dragoes)
teste.de.normalidade=shapiro.test(dragoes$y)
if (teste.de.normalidade$p.value >= 0.05){
  fit = lm(dragoes$y ~ dragoes$x)
  summary(fit)
  plot(dragoes, main="normal")
} else {
  kruskal.test(dragoes)
  x11()
  plot(dragoes, main="kruskal")
}
  #agora crie um c√≥digo  como acima, mas que diga "par" se for par e "impar" se
#for impar. Dica: leia sobre as fun√ß√µes else e ifelse

for(i in 1:length(dragoes$y)) {
  a = dragoes$y[i]
  message(a)
}

for(i in 1:length(cx)) {
  x11()
  plot(cx[,i])
  }

for(contador in 10:1) {
  message(contador + 1)
}

for (i in 10:1){
  message()
  }
#crie um ciclo (for) que mostre o console todos os inteiros de 1 at√© 10, um por
#um

for(i in 1:10){
  message(i)
  }


#crie um ciclo (for) que some todos os inteiros de 25 at√© 43, guardando esses
#valores num objeto soma (dica: crie o objeto soma com valor zero antes do
#c√≥digo do ciclo)

soma=0
for(i in 25:43){
soma=soma+i
message(soma)
}



#####Desafio level Hard#####
#Escreva um c√≥digo que escreva os n√∫meros de um a 100, com as seguintes
#condi√ß√µes: Se o n√∫mero for multiplo de 3, ao inv√©s do d√?gito, escreva "Fu". Se
#o n√∫mero for m√∫ltiplo de 5, ao inv√©s do d√?gito, escreva "b√°". Para n√∫meros que
#forem multiplos tanto de 3 quanto de 5, escreva "Fub√°". A melhor solu√ß√£o ganha
#um chocolate